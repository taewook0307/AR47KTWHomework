#include <iostream>

int main()
{
    int Left = 0b00000000000000000000000000000010;
    int Right = 0b00000000000000000000000000000001;
    int Result = 0b00000000000000000000000000000000;

    //비트 단위 연산자 => 각 비트 단위를 전부 비교

    //and                       둘 다 1인 경우 true
    Result = Left & Right;      
    //0b00000000000000000000000000000010
    //0b00000000000000000000000000000001
    //0b00000000000000000000000000000000

    //or                        둘 중 하나만 1이어도 true
    Result = Left | Right;
    //0b00000000000000000000000000000010
    //0b00000000000000000000000000000001
    //0b00000000000000000000000000000011

    //not                       1이면 false, 0이면 true
    Result = ~Left;
    //0b00000000000000000000000000000010
    //0b11111111111111111111111111111101;

    //xor                       둘이 다를때만 true, 둘이 1로 같든 0으로 같든 상관없이 같으면 false
    Result = Left ^ Right;
    //0b00000000000000000000000000000010
    //0b00000000000000000000000000000001
    //0b00000000000000000000000000000011

    //true와 false 참과 거짓의 명확한 의미
    //특정 메모리 영역의 비트가 전부 0이라면 false와 거짓
    //특정 메모리 영역의 비트 중 단 1개라도 1이 있다면 true
    //true = 1, false = 0 <= 잘못된 개념

    bool bResult = 2; // <= bResult의 값은 true

    //Shift                     뒤에 있는 정수수만큼 비트를 옮김
    Result = 1 << 3;            //왼쪽으로 3만큼 비트 이동
    //0b00000000000000000000000000000001
    //0b00000000000000000000000000001000

    Result = 2 >> 1;            //오른쪽으로 1만큼 비트 이동

    //Result = Result << 33;                <= 32비트인 Result보다 많이 넘길경우 값이 손실될 수 있음 : 스택 오버플로
    //Result = 1 >> 1;                      <=값 손실

    //축약 연산자
    //복합 할당 연산자
    //특정 메모리 영역의 값을 기반으로 하는 이항 연산자
    int Value = 20;

    Value += 20;            // Value = Value + 20;
    Value -= 10;            // Value = Value - 10;
    Value *= 10;            // Value = Value * 10;
    Value /= 10;            // Value = Value / 10;
    Value %= 10;            // Value = Value % 10;
    Value &= 1;             // Value = Value & 1;
}
